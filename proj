#!/usr/bin/env bash
# ~/.proj/proj
# (salva questo file come ~/.proj/proj e rendilo eseguibile)


set -euo pipefail
shopt -s nullglob


BASE_DIR="${HOME}/.proj"
TEMPLATE_DIR="$BASE_DIR/templates"
LIB_DIR="$BASE_DIR/libraries"


usage() {
cat <<EOF
Usage: proj <command> [options]


Commands:
new -t <c|c++> -n <name> Create a new project
add-lib <libname> [--mode copy|ref] [--content full|headers]
remove-lib <libname> Remove lib from project
update-lib <libname> Refresh lib from archive
update Update project Makefile fragments
build Build project (and compiled copied libs)
exec execute the project
package Create a portable tar.gz of project
help


Examples:
proj new -t c++ -n myapp
proj add-lib mylib --mode copy --content full
proj remove-lib mylib
proj update-lib  #all
proj update-lib mylib
proj update
proj build
proj exec
proj package
EOF
}

# Helpers
err() { echo "[ERROR] $*" >&2; }
info() { echo "[INFO] $*"; }


require_jq() {
if ! command -v jq >/dev/null 2>&1; then
err "jq is required for JSON parsing. Install it (apt, brew, etc.)"
exit 1
fi
}


# Create a new project
cmd_new() {
local TYPE NAME
while [[ $# -gt 0 ]]; do
case "$1" in
-t|--type) TYPE="$2"; shift 2;;
-n|--name) NAME="$2"; shift 2;;
-h|--help) usage; exit 0;;
*) err "Unknown option $1"; usage; exit 1;;
esac
done


if [[ -z "${TYPE:-}" || -z "${NAME:-}" ]]; then
err "type and name are required"; usage; exit 1
fi


if [[ "$TYPE" != "c" && "$TYPE" != "c++" ]]; then
err "Type must be c or c++"; exit 1
fi


mkdir -p "$NAME" && cd "$NAME"
mkdir -p src include obj bin libs


# Copia i file template
if [[ "$TYPE" == "c" ]]; then
    cp "$TEMPLATE_DIR/c/main.c" "src/main.c"
    cp "$TEMPLATE_DIR/c/Makefile" Makefile
else
    cp "$TEMPLATE_DIR/cpp/main.cpp" "src/main.cpp"
    cp "$TEMPLATE_DIR/cpp/Makefile" Makefile
fi

# Sostituisci il PROJECT_NAME nel Makefile (solo eseguibile)
sed -i "s/{{PROJECT_NAME}}/$NAME/g" Makefile



# placeholder libs.mk
cat > libs.mk <<'EOF'
# libs.mk - generated by proj
INCLUDE_DIRS :=
LIB_DIRS :=
LIBS :=
CFLAGS_EXTRA :=
LDFLAGS_EXTRA :=
EOF


info "Project '$NAME' created. Edit src/ and run: proj add-lib <libname> or proj build"
}


# Adds a library to current project
cmd_add_lib() {
require_jq
local LIB MODE="ref" CONTENT="full"
LIB="$1"; shift || { err "lib name required"; exit 1; }
while [[ $# -gt 0 ]]; do
case "$1" in
--mode) MODE="$2"; shift 2;;
--content) CONTENT="$2"; shift 2;;
*) err "Unknown option: $1"; exit 1;;
esac
done


if [[ ! -d "$LIB_DIR/$LIB" ]]; then
err "Library $LIB not found in $LIB_DIR"
exit 1
fi


# ensure projlib.json exists
if [[ ! -f "$LIB_DIR/$LIB/projlib.json" ]]; then
err "Missing projlib.json in library $LIB"
exit 1
fi


# Read metadata
local INCLUDE_SUB SRC_SUB BIN_SUB
INCLUDE_SUB=$(jq -r '.include_dir // "include"' "$LIB_DIR/$LIB/projlib.json")
SRC_SUB=$(jq -r '.src_dir // "src"' "$LIB_DIR/$LIB/projlib.json")
BIN_SUB=$(jq -r '.bin_dir // "bin"' "$LIB_DIR/$LIB/projlib.json")


mkdir -p libs


if [[ "$MODE" == "copy" ]]; then
info "Copying library $LIB into project/libs/$LIB"
rm -rf "libs/$LIB"
mkdir -p "libs/$LIB"

# copy Makefile
if [[ -f "$LIB_DIR/$LIB/Makefile" ]]; then
  cp "$LIB_DIR/$LIB/Makefile" "libs/$LIB/Makefile"
else
  err "Library $LIB has no Makefile"
  exit 1
fi

# copy include and bin always
if [[ -d "$LIB_DIR/$LIB/$INCLUDE_SUB" ]]; then
cp -r "$LIB_DIR/$LIB/$INCLUDE_SUB" "libs/$LIB/$INCLUDE_SUB"
fi
if [[ -d "$LIB_DIR/$LIB/$BIN_SUB" ]]; then
cp -r "$LIB_DIR/$LIB/$BIN_SUB" "libs/$LIB/$BIN_SUB"
fi
if [[ "$CONTENT" == "full" && -d "$LIB_DIR/$LIB/$SRC_SUB" ]]; then
cp -r "$LIB_DIR/$LIB/$SRC_SUB" "libs/$LIB/$SRC_SUB"
fi


# If copied and src exists, build it
if [[ -d "libs/$LIB/$SRC_SUB" ]]; then
info "Building copied library $LIB"
make -C "libs/$LIB" || { err "Failed building library $LIB"; exit 1; }
fi

# Add to libs.mk
add_lib_to_libs_mk "libs/$LIB" "$LIB" "copy"
else
info "Referencing library $LIB from $LIB_DIR/$LIB"
# create a symlink in libs/ to original (for clarity) or just reference path
mkdir -p libs
ln -sfn "$LIB_DIR/$LIB" "libs/$LIB"
add_lib_to_libs_mk "$LIB_DIR/$LIB" "$LIB" "ref"
fi


info "Library $LIB added"
}


# Remove a library from project
cmd_remove_lib() {
local LIB="$1"
if [[ -z "$LIB" ]]; then err "lib name required"; exit 1; fi
# remove symlink or copy
if [[ -L "libs/$LIB" || -d "libs/$LIB" ]]; then
rm -rf "libs/$LIB"
fi
# remove from libs.mk
if [[ -f libs.mk ]]; then
# naive delete lines containing the lib path
sed -i "/${LIB//\//\\\/}/d" libs.mk || true
fi
info "Library $LIB removed from project"
}


# Add or update libs.mk entries
add_lib_to_libs_mk() {
local PATH_TO_LIB="$1" NAME="$2" MODE="$3"
# compute include and lib dirs
local INCDIR="$PATH_TO_LIB/include"
local BINDIR="$PATH_TO_LIB/bin"


# ensure libs.mk exists
touch libs.mk


# Add include
if [[ -d "$INCDIR" ]]; then
# add -I path
local ILINE="INCLUDE_DIRS += -I$(realpath "$INCDIR")"
grep -F "$ILINE" libs.mk >/dev/null 2>&1 || echo "$ILINE" >> libs.mk
fi


# Add lib dir and lib
if [[ -d "$BINDIR" ]]; then
local LL="LIB_DIRS += -L$(realpath "$BINDIR")"
grep -F "$LL" libs.mk >/dev/null 2>&1 || echo "$LL" >> libs.mk


# add lib name(s) based on files in bin
for f in "$BINDIR"/lib*.a; do
[[ -e "$f" ]] || continue
local libfile=$(basename "$f")
# libname: strip lib prefix and .a
local libname=${libfile#lib}
libname=${libname%.a}
local LLIB="LIBS += -l$libname"
grep -F "$LLIB" libs.mk >/dev/null 2>&1 || echo "$LLIB" >> libs.mk
done
fi
}
# mark source copy if present


# Update: refresh libs.mk (re-scan libs/)
cmd_update() {
    info "Updating all libraries in project..."

    # svuota libs.mk e scrive intestazione
    > libs.mk
    echo "# libs.mk - generated by proj (do not edit)" > libs.mk

    # cicla su tutte le cartelle in libs/
    for d in libs/*/; do
        [[ -d "$d" ]] || continue
        libname=$(basename "$d")

        # controlla se Ã¨ un symlink (ref) o cartella fisica (copy)
        if [[ -L "$d" ]]; then
            info "Updating referenced library: $libname"
            # riferimenti non compilano, solo aggiorna libs.mk
            add_lib_to_libs_mk "$d" "$libname" "ref"
        else
            info "Updating copied library: $libname"

            # aggiorna projlib.json con i percorsi attuali
            if [[ -f "$d/projlib.json" ]]; then
                INCLUDE_SUB=$(jq -r '.include_dir // "include"' "$d/projlib.json")
                SRC_SUB=$(jq -r '.src_dir // "src"' "$d/projlib.json")
                BIN_SUB=$(jq -r '.bin_dir // "bin"' "$d/projlib.json")
                jq --arg inc "$INCLUDE_SUB" --arg src "$SRC_SUB" --arg bin "$BIN_SUB" \
                   '.include_dir=$inc | .src_dir=$src | .bin_dir=$bin' "$d/projlib.json" \
                   > "$d/projlib.json.tmp" && mv "$d/projlib.json.tmp" "$d/projlib.json"
            fi

            # aggiorna libs.mk
            add_lib_to_libs_mk "$d" "$libname" "copy"

            # ricompila la libreria se ha src/
            if [[ -d "$d/src" ]]; then
                info "Rebuilding copied library $libname"
                make -C "$d" || { err "Failed building library $libname"; exit 1; }
            fi
        fi
    done

    info "All libraries updated successfully"
}


# Build: first build copied libs that have source, then project
cmd_build() {
# build copied libs
for d in libs/*/; do
[[ -d "$d" ]] || continue
if [[ -d "$d/src" ]]; then
info "Building library $(basename "$d")"
make -C "$d" || { err "Failed building library "; exit 1; }
fi
done

# then project
info "Running make for project"
make
}

# Execute:
cmd_execute(){
  # esegui l'eseguibile nella cartella bin/
  EXE="bin/$(basename "$(pwd)")"
  if [[ -f "$EXE" ]]; then
    ./"$EXE"
  else
    err "Executable $EXE not found!"
  fi
}

#Update:
cmd_update_lib() {
    require_jq
    local TARGET=""
    if [[ $# -ge 1 ]]; then
        TARGET="$1"
    fi

    local LIBS_TO_UPDATE=()

    if [[ -n "$TARGET" ]]; then
        # Aggiorna solo la libreria specificata
        if [[ -d "libs/$TARGET" && ! -L "libs/$TARGET" ]]; then
            LIBS_TO_UPDATE=("$TARGET")
        else
            err "Library $TARGET not found or is a reference"
            return 1
        fi
    else
        # Aggiorna tutte le librerie copiate
        for d in libs/*/; do
            [[ -d "$d" ]] || continue
            [[ -L "$d" ]] && continue  # salta symlink
            LIBS_TO_UPDATE+=("$(basename "$d")")
        done
    fi

    for lib in "${LIBS_TO_UPDATE[@]}"; do
        info "Updating library $lib"

        # cancella vecchia copia
        rm -rf "libs/$lib"
        mkdir -p "libs/$lib"

        # ricopia da librerie originali
        if [[ -d "$LIB_DIR/$lib/include" ]]; then
            cp -r "$LIB_DIR/$lib/include" "libs/$lib/include"
        fi
        if [[ -d "$LIB_DIR/$lib/bin" ]]; then
            cp -r "$LIB_DIR/$lib/bin" "libs/$lib/bin"
        fi
        if [[ -d "$LIB_DIR/$lib/src" ]]; then
            cp -r "$LIB_DIR/$lib/src" "libs/$lib/src"
        fi

        # aggiorna projlib.json
        if [[ -f "$LIB_DIR/$lib/projlib.json" ]]; then
            cp "$LIB_DIR/$lib/projlib.json" "libs/$lib/projlib.json"
        fi

        # copia Makefile se esiste
        if [[ -f "$LIB_DIR/$lib/Makefile" ]]; then
            cp "$LIB_DIR/$lib/Makefile" "libs/$lib/Makefile"
        fi

        # aggiorna libs.mk
        add_lib_to_libs_mk "libs/$lib" "$lib" "copy"

    done

    info "Library update completed successfully"
}



# Package project (portable)
cmd_package() {
# for portability: make a tmp dir, copy project, copy all referenced libraries into libs/, build everything, tar.gz
local PROJECT_DIR="$(pwd)"
local NAME="$(basename "$PROJECT_DIR")"
local TMPDIR=$(mktemp -d)
cp -r "$PROJECT_DIR" "$TMPDIR/$NAME"


pushd "$TMPDIR/$NAME" >/dev/null
# ensure all libs are copied (if some are refs)
for d in libs/*/; do
if [[ -L "$d" ]]; then
local target=$(readlink -f "$d")
rm -f "$d"
cp -r "$target" "${d%/}"
fi
done


# build libraries and project
for d in libs/*/; do
if [[ -d "$d/src" ]]; then
make -C "$d" || { err "Failed building lib in package"; popd >/dev/null; rm -rf "$TMPDIR"; exit 1; }
fi
done
make || { err "Failed building project in package"; popd >/dev/null; rm -rf "$TMPDIR"; exit 1; }


# create tar.gz
tar -czf "${PROJECT_DIR}-${NAME}-portable.tar.gz" -C "$TMPDIR" "$NAME"
popd >/dev/null
mv "$TMPDIR/${NAME}.tar.gz" . 2>/dev/null || true
# actually our created file path
mv "$TMPDIR/$NAME"*"portable.tar.gz" "$PROJECT_DIR/" 2>/dev/null || true
info "Created portable package in $PROJECT_DIR"
rm -rf "$TMPDIR"
}

# CLI dispatcher
if [[ $# -lt 1 ]]; then usage; exit 0; fi
cmd="$1"; shift
case "$cmd" in
new) cmd_new "$@" ;;
add-lib) cmd_add_lib "$@" ;;
remove-lib) cmd_remove_lib "$@" ;;
update-lib) cmd_update_lib "$@" ;;
update) cmd_update ;;
build) cmd_build ;;
exec) cmd_execute ;;
package) cmd_package ;;
help|-h|--help) usage ;;
*) err "Unknown command $cmd"; usage; exit 1 ;;
esac